{"version":3,"sources":["../../../../src/exact/facilitator/index.ts","../../../../src/exact/facilitator/scheme.ts","../../../../src/constants.ts","../../../../src/exact/v1/facilitator/scheme.ts","../../../../src/utils.ts","../../../../src/exact/v1/client/scheme.ts","../../../../src/v1/index.ts","../../../../src/exact/facilitator/register.ts"],"sourcesContent":["export { ExactEvmScheme } from \"./scheme\";\nexport type { ExactEvmSchemeConfig } from \"./scheme\";\nexport { registerExactEvmScheme } from \"./register\";\nexport type { EvmFacilitatorConfig } from \"./register\";\n","import {\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { getAddress, Hex, isAddressEqual, parseErc6492Signature, parseSignature } from \"viem\";\nimport { authorizationTypes, eip3009ABI } from \"../../constants\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmPayloadV2 } from \"../../types\";\n\nexport interface ExactEvmSchemeConfig {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * EVM facilitator implementation for the Exact payment scheme.\n */\nexport class ExactEvmScheme implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"eip155:*\";\n  private readonly config: Required<ExactEvmSchemeConfig>;\n\n  /**\n   * Creates a new ExactEvmFacilitator instance.\n   *\n   * @param signer - The EVM signer for facilitator operations\n   * @param config - Optional configuration for the facilitator\n   */\n  constructor(\n    private readonly signer: FacilitatorEvmSigner,\n    config?: ExactEvmSchemeConfig,\n  ) {\n    this.config = {\n      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false,\n    };\n  }\n\n  /**\n   * Get mechanism-specific extra data for the supported kinds endpoint.\n   * For EVM, no extra data is needed.\n   *\n   * @param _ - The network identifier (unused for EVM)\n   * @returns undefined (EVM has no extra data)\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Get signer addresses used by this facilitator.\n   * Returns all addresses this facilitator can use for signing/settling transactions.\n   *\n   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)\n   * @returns Array of facilitator wallet addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload.\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV2;\n\n    // Verify scheme matches\n    if (payload.accepted.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n      return {\n        isValid: false,\n        invalidReason: \"unsupported_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Get chain configuration\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      return {\n        isValid: false,\n        invalidReason: \"missing_eip712_domain\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    const { name, version } = requirements.extra;\n    const erc20Address = getAddress(requirements.asset);\n\n    // Verify network matches\n    if (payload.accepted.network !== requirements.network) {\n      return {\n        isValid: false,\n        invalidReason: \"network_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Build typed data for signature verification\n    const permitTypedData = {\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\" as const,\n      domain: {\n        name,\n        version,\n        chainId: parseInt(requirements.network.split(\":\")[1]),\n        verifyingContract: erc20Address,\n      },\n      message: {\n        from: exactEvmPayload.authorization.from,\n        to: exactEvmPayload.authorization.to,\n        value: BigInt(exactEvmPayload.authorization.value),\n        validAfter: BigInt(exactEvmPayload.authorization.validAfter),\n        validBefore: BigInt(exactEvmPayload.authorization.validBefore),\n        nonce: exactEvmPayload.authorization.nonce,\n      },\n    };\n\n    // Verify signature\n    try {\n      const recoveredAddress = await this.signer.verifyTypedData({\n        address: exactEvmPayload.authorization.from,\n        ...permitTypedData,\n        signature: exactEvmPayload.signature!,\n      });\n\n      if (!recoveredAddress) {\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // Signature verification failed - could be an undeployed smart wallet\n      // Check if smart wallet is deployed\n      const signature = exactEvmPayload.signature!;\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isSmartWallet = signatureLength > 130; // 65 bytes = 130 hex chars for EOA\n\n      if (isSmartWallet) {\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet is not deployed. Check if it's EIP-6492 with deployment info.\n          // EIP-6492 signatures contain factory address and calldata needed for deployment.\n          // Non-EIP-6492 undeployed wallets cannot succeed (no way to deploy them).\n          const erc6492Data = parseErc6492Signature(signature);\n          const hasDeploymentInfo =\n            erc6492Data.address &&\n            erc6492Data.data &&\n            !isAddressEqual(erc6492Data.address, \"0x0000000000000000000000000000000000000000\");\n\n          if (!hasDeploymentInfo) {\n            // Non-EIP-6492 undeployed smart wallet - will always fail at settlement\n            // since EIP-3009 requires on-chain EIP-1271 validation\n            return {\n              isValid: false,\n              invalidReason: \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n              payer: payerAddress,\n            };\n          }\n          // EIP-6492 signature with deployment info - allow through\n          // Facilitators with sponsored deployment support can handle this in settle()\n        } else {\n          // Wallet is deployed but signature still failed - invalid signature\n          return {\n            isValid: false,\n            invalidReason: \"invalid_exact_evm_payload_signature\",\n            payer: exactEvmPayload.authorization.from,\n          };\n        }\n      } else {\n        // EOA signature failed\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    }\n\n    // Verify payment recipient matches\n    if (getAddress(exactEvmPayload.authorization.to) !== getAddress(requirements.payTo)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validBefore is in the future (with 6 second buffer for block time)\n    const now = Math.floor(Date.now() / 1000);\n    if (BigInt(exactEvmPayload.authorization.validBefore) < BigInt(now + 6)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validAfter is not in the future\n    if (BigInt(exactEvmPayload.authorization.validAfter) > BigInt(now)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Check balance\n    try {\n      const balance = (await this.signer.readContract({\n        address: erc20Address,\n        abi: eip3009ABI,\n        functionName: \"balanceOf\",\n        args: [exactEvmPayload.authorization.from],\n      })) as bigint;\n\n      if (BigInt(balance) < BigInt(requirements.amount)) {\n        return {\n          isValid: false,\n          invalidReason: \"insufficient_funds\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // If we can't check balance, continue with other validations\n    }\n\n    // Verify amount is sufficient\n    if (BigInt(exactEvmPayload.authorization.value) < BigInt(requirements.amount)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_value\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    return {\n      isValid: true,\n      invalidReason: undefined,\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  /**\n   * Settles a payment by executing the transfer.\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV2;\n\n    // Re-verify before settling\n    const valid = await this.verify(payload, requirements);\n    if (!valid.isValid) {\n      return {\n        success: false,\n        network: payload.accepted.network,\n        transaction: \"\",\n        errorReason: valid.invalidReason ?? \"invalid_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    try {\n      // Parse ERC-6492 signature if applicable\n      const parseResult = parseErc6492Signature(exactEvmPayload.signature!);\n      const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;\n\n      // Deploy ERC-4337 smart wallet via EIP-6492 if configured and needed\n      if (\n        this.config.deployERC4337WithEIP6492 &&\n        factoryAddress &&\n        factoryCalldata &&\n        !isAddressEqual(factoryAddress, \"0x0000000000000000000000000000000000000000\")\n      ) {\n        // Check if smart wallet is already deployed\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet not deployed - attempt deployment\n          try {\n            console.log(`Deploying ERC-4337 smart wallet for ${payerAddress} via EIP-6492`);\n\n            // Send the factory calldata directly as a transaction\n            // The factoryCalldata already contains the complete encoded function call\n            const deployTx = await this.signer.sendTransaction({\n              to: factoryAddress as Hex,\n              data: factoryCalldata as Hex,\n            });\n\n            // Wait for deployment transaction\n            await this.signer.waitForTransactionReceipt({ hash: deployTx });\n            console.log(`Successfully deployed smart wallet for ${payerAddress}`);\n          } catch (deployError) {\n            console.error(\"Smart wallet deployment failed:\", deployError);\n            // Deployment failed - cannot proceed\n            throw deployError;\n          }\n        } else {\n          console.log(`Smart wallet for ${payerAddress} already deployed, skipping deployment`);\n        }\n      }\n\n      // Determine if this is an ECDSA signature (EOA) or smart wallet signature\n      // ECDSA signatures are exactly 65 bytes (130 hex chars without 0x)\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isECDSA = signatureLength === 130;\n\n      let tx: Hex;\n      if (isECDSA) {\n        // For EOA wallets, parse signature into v, r, s and use that overload\n        const parsedSig = parseSignature(signature);\n\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            (parsedSig.v as number | undefined) || parsedSig.yParity,\n            parsedSig.r,\n            parsedSig.s,\n          ],\n        });\n      } else {\n        // For smart wallets, use the bytes signature overload\n        // The signature contains WebAuthn/P256 or other ERC-1271 compatible signature data\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            signature,\n          ],\n        });\n      }\n\n      // Wait for transaction confirmation\n      const receipt = await this.signer.waitForTransactionReceipt({ hash: tx });\n\n      if (receipt.status !== \"success\") {\n        return {\n          success: false,\n          errorReason: \"invalid_transaction_state\",\n          transaction: tx,\n          network: payload.accepted.network,\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n\n      return {\n        success: true,\n        transaction: tx,\n        network: payload.accepted.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    } catch (error) {\n      console.error(\"Failed to settle transaction:\", error);\n      return {\n        success: false,\n        errorReason: \"transaction_failed\",\n        transaction: \"\",\n        network: payload.accepted.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n  }\n}\n","// EIP-3009 TransferWithAuthorization types for EIP-712 signing\nexport const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n} as const;\n\n// EIP3009 ABI for transferWithAuthorization function\nexport const eip3009ABI = [\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"v\", type: \"uint8\" },\n      { name: \"r\", type: \"bytes32\" },\n      { name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n","import {\n  PaymentPayload,\n  PaymentPayloadV1,\n  PaymentRequirements,\n  SchemeNetworkFacilitator,\n  SettleResponse,\n  VerifyResponse,\n} from \"@x402/core/types\";\nimport { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { getAddress, Hex, isAddressEqual, parseErc6492Signature, parseSignature } from \"viem\";\nimport { authorizationTypes, eip3009ABI } from \"../../../constants\";\nimport { FacilitatorEvmSigner } from \"../../../signer\";\nimport { ExactEvmPayloadV1 } from \"../../../types\";\nimport { getEvmChainId } from \"../../../utils\";\n\nexport interface ExactEvmSchemeV1Config {\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * EVM facilitator implementation for the Exact payment scheme (V1).\n */\nexport class ExactEvmSchemeV1 implements SchemeNetworkFacilitator {\n  readonly scheme = \"exact\";\n  readonly caipFamily = \"eip155:*\";\n  private readonly config: Required<ExactEvmSchemeV1Config>;\n\n  /**\n   * Creates a new ExactEvmFacilitatorV1 instance.\n   *\n   * @param signer - The EVM signer for facilitator operations\n   * @param config - Optional configuration for the facilitator\n   */\n  constructor(\n    private readonly signer: FacilitatorEvmSigner,\n    config?: ExactEvmSchemeV1Config,\n  ) {\n    this.config = {\n      deployERC4337WithEIP6492: config?.deployERC4337WithEIP6492 ?? false,\n    };\n  }\n\n  /**\n   * Get mechanism-specific extra data for the supported kinds endpoint.\n   * For EVM, no extra data is needed.\n   *\n   * @param _ - The network identifier (unused for EVM)\n   * @returns undefined (EVM has no extra data)\n   */\n  getExtra(_: string): Record<string, unknown> | undefined {\n    return undefined;\n  }\n\n  /**\n   * Get signer addresses used by this facilitator.\n   * Returns all addresses this facilitator can use for signing/settling transactions.\n   *\n   * @param _ - The network identifier (unused for EVM, addresses are network-agnostic)\n   * @returns Array of facilitator wallet addresses\n   */\n  getSigners(_: string): string[] {\n    return [...this.signer.getAddresses()];\n  }\n\n  /**\n   * Verifies a payment payload (V1).\n   *\n   * @param payload - The payment payload to verify\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to verification response\n   */\n  async verify(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<VerifyResponse> {\n    const requirementsV1 = requirements as unknown as PaymentRequirementsV1;\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV1;\n\n    // Verify scheme matches\n    if (payloadV1.scheme !== \"exact\" || requirements.scheme !== \"exact\") {\n      return {\n        isValid: false,\n        invalidReason: \"unsupported_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Get chain configuration\n    const chainId = getEvmChainId(payloadV1.network);\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      return {\n        isValid: false,\n        invalidReason: \"missing_eip712_domain\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    const { name, version } = requirements.extra;\n    const erc20Address = getAddress(requirements.asset);\n\n    // Verify network matches\n    if (payloadV1.network !== requirements.network) {\n      return {\n        isValid: false,\n        invalidReason: \"network_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Build typed data for signature verification\n    const permitTypedData = {\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\" as const,\n      domain: {\n        name,\n        version,\n        chainId,\n        verifyingContract: erc20Address,\n      },\n      message: {\n        from: exactEvmPayload.authorization.from,\n        to: exactEvmPayload.authorization.to,\n        value: BigInt(exactEvmPayload.authorization.value),\n        validAfter: BigInt(exactEvmPayload.authorization.validAfter),\n        validBefore: BigInt(exactEvmPayload.authorization.validBefore),\n        nonce: exactEvmPayload.authorization.nonce,\n      },\n    };\n\n    // Verify signature\n    try {\n      const recoveredAddress = await this.signer.verifyTypedData({\n        address: exactEvmPayload.authorization.from,\n        ...permitTypedData,\n        signature: exactEvmPayload.signature!,\n      });\n\n      if (!recoveredAddress) {\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // Signature verification failed - could be an undeployed smart wallet\n      // Check if smart wallet is deployed\n      const signature = exactEvmPayload.signature!;\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isSmartWallet = signatureLength > 130; // 65 bytes = 130 hex chars for EOA\n\n      if (isSmartWallet) {\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet is not deployed. Check if it's EIP-6492 with deployment info.\n          // EIP-6492 signatures contain factory address and calldata needed for deployment.\n          // Non-EIP-6492 undeployed wallets cannot succeed (no way to deploy them).\n          const erc6492Data = parseErc6492Signature(signature);\n          const hasDeploymentInfo =\n            erc6492Data.address &&\n            erc6492Data.data &&\n            !isAddressEqual(erc6492Data.address, \"0x0000000000000000000000000000000000000000\");\n\n          if (!hasDeploymentInfo) {\n            // Non-EIP-6492 undeployed smart wallet - will always fail at settlement\n            // since EIP-3009 requires on-chain EIP-1271 validation\n            return {\n              isValid: false,\n              invalidReason: \"invalid_exact_evm_payload_undeployed_smart_wallet\",\n              payer: payerAddress,\n            };\n          }\n          // EIP-6492 signature with deployment info - allow through\n          // Facilitators with sponsored deployment support can handle this in settle()\n        } else {\n          // Wallet is deployed but signature still failed - invalid signature\n          return {\n            isValid: false,\n            invalidReason: \"invalid_exact_evm_payload_signature\",\n            payer: exactEvmPayload.authorization.from,\n          };\n        }\n      } else {\n        // EOA signature failed\n        return {\n          isValid: false,\n          invalidReason: \"invalid_exact_evm_payload_signature\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    }\n\n    // Verify payment recipient matches\n    if (getAddress(exactEvmPayload.authorization.to) !== getAddress(requirements.payTo)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validBefore is in the future (with 6 second buffer for block time)\n    const now = Math.floor(Date.now() / 1000);\n    if (BigInt(exactEvmPayload.authorization.validBefore) < BigInt(now + 6)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Verify validAfter is not in the future\n    if (BigInt(exactEvmPayload.authorization.validAfter) > BigInt(now)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    // Check balance\n    try {\n      const balance = (await this.signer.readContract({\n        address: erc20Address,\n        abi: eip3009ABI,\n        functionName: \"balanceOf\",\n        args: [exactEvmPayload.authorization.from],\n      })) as bigint;\n\n      if (BigInt(balance) < BigInt(requirementsV1.maxAmountRequired)) {\n        return {\n          isValid: false,\n          invalidReason: \"insufficient_funds\",\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n    } catch {\n      // If we can't check balance, continue with other validations\n    }\n\n    // Verify amount is sufficient\n    if (BigInt(exactEvmPayload.authorization.value) < BigInt(requirementsV1.maxAmountRequired)) {\n      return {\n        isValid: false,\n        invalidReason: \"invalid_exact_evm_payload_authorization_value\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    return {\n      isValid: true,\n      invalidReason: undefined,\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  /**\n   * Settles a payment by executing the transfer (V1).\n   *\n   * @param payload - The payment payload to settle\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to settlement response\n   */\n  async settle(\n    payload: PaymentPayload,\n    requirements: PaymentRequirements,\n  ): Promise<SettleResponse> {\n    const payloadV1 = payload as unknown as PaymentPayloadV1;\n    const exactEvmPayload = payload.payload as ExactEvmPayloadV1;\n\n    // Re-verify before settling\n    const valid = await this.verify(payload, requirements);\n    if (!valid.isValid) {\n      return {\n        success: false,\n        network: payloadV1.network,\n        transaction: \"\",\n        errorReason: valid.invalidReason ?? \"invalid_scheme\",\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n\n    try {\n      // Parse ERC-6492 signature if applicable\n      const parseResult = parseErc6492Signature(exactEvmPayload.signature!);\n      const { signature, address: factoryAddress, data: factoryCalldata } = parseResult;\n\n      // Deploy ERC-4337 smart wallet via EIP-6492 if configured and needed\n      if (\n        this.config.deployERC4337WithEIP6492 &&\n        factoryAddress &&\n        factoryCalldata &&\n        !isAddressEqual(factoryAddress, \"0x0000000000000000000000000000000000000000\")\n      ) {\n        // Check if smart wallet is already deployed\n        const payerAddress = exactEvmPayload.authorization.from;\n        const bytecode = await this.signer.getCode({ address: payerAddress });\n\n        if (!bytecode || bytecode === \"0x\") {\n          // Wallet not deployed - attempt deployment\n          try {\n            console.log(`Deploying ERC-4337 smart wallet for ${payerAddress} via EIP-6492`);\n\n            // Send the factory calldata directly as a transaction\n            // The factoryCalldata already contains the complete encoded function call\n            const deployTx = await this.signer.sendTransaction({\n              to: factoryAddress as Hex,\n              data: factoryCalldata as Hex,\n            });\n\n            // Wait for deployment transaction\n            await this.signer.waitForTransactionReceipt({ hash: deployTx });\n            console.log(`Successfully deployed smart wallet for ${payerAddress}`);\n          } catch (deployError) {\n            console.error(\"Smart wallet deployment failed:\", deployError);\n            // Deployment failed - cannot proceed\n            throw deployError;\n          }\n        } else {\n          console.log(`Smart wallet for ${payerAddress} already deployed, skipping deployment`);\n        }\n      }\n\n      // Determine if this is an ECDSA signature (EOA) or smart wallet signature\n      // ECDSA signatures are exactly 65 bytes (130 hex chars without 0x)\n      const signatureLength = signature.startsWith(\"0x\") ? signature.length - 2 : signature.length;\n      const isECDSA = signatureLength === 130;\n\n      let tx: Hex;\n      if (isECDSA) {\n        // For EOA wallets, parse signature into v, r, s and use that overload\n        const parsedSig = parseSignature(signature);\n\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            (parsedSig.v as number | undefined) || parsedSig.yParity,\n            parsedSig.r,\n            parsedSig.s,\n          ],\n        });\n      } else {\n        // For smart wallets, use the bytes signature overload\n        // The signature contains WebAuthn/P256 or other ERC-1271 compatible signature data\n        tx = await this.signer.writeContract({\n          address: getAddress(requirements.asset),\n          abi: eip3009ABI,\n          functionName: \"transferWithAuthorization\",\n          args: [\n            getAddress(exactEvmPayload.authorization.from),\n            getAddress(exactEvmPayload.authorization.to),\n            BigInt(exactEvmPayload.authorization.value),\n            BigInt(exactEvmPayload.authorization.validAfter),\n            BigInt(exactEvmPayload.authorization.validBefore),\n            exactEvmPayload.authorization.nonce,\n            signature,\n          ],\n        });\n      }\n\n      // Wait for transaction confirmation\n      const receipt = await this.signer.waitForTransactionReceipt({ hash: tx });\n\n      if (receipt.status !== \"success\") {\n        return {\n          success: false,\n          errorReason: \"invalid_transaction_state\",\n          transaction: tx,\n          network: payloadV1.network,\n          payer: exactEvmPayload.authorization.from,\n        };\n      }\n\n      return {\n        success: true,\n        transaction: tx,\n        network: payloadV1.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    } catch (error) {\n      console.error(\"Failed to settle transaction:\", error);\n      return {\n        success: false,\n        errorReason: \"transaction_failed\",\n        transaction: \"\",\n        network: payloadV1.network,\n        payer: exactEvmPayload.authorization.from,\n      };\n    }\n  }\n}\n","import { toHex } from \"viem\";\nimport { Network } from \"@x402/core/types\";\n\n/**\n * Extract chain ID from network string (e.g., \"base-sepolia\" -> 84532)\n * Used by v1 implementations\n *\n * @param network - The network identifier\n * @returns The numeric chain ID\n */\nexport function getEvmChainId(network: Network): number {\n  const networkMap: Record<string, number> = {\n    base: 8453,\n    \"base-sepolia\": 84532,\n    ethereum: 1,\n    sepolia: 11155111,\n    polygon: 137,\n    \"polygon-amoy\": 80002,\n  };\n  return networkMap[network] || 1;\n}\n\n/**\n * Create a random 32-byte nonce for authorization\n *\n * @returns A hex-encoded 32-byte nonce\n */\nexport function createNonce(): `0x${string}` {\n  // Use dynamic import to avoid require() in ESM context\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\"\n      ? globalThis.crypto\n      : (globalThis as { crypto?: Crypto }).crypto;\n\n  if (!cryptoObj) {\n    throw new Error(\"Crypto API not available\");\n  }\n\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","import {\n  Network,\n  PaymentPayload,\n  PaymentRequirements,\n  SchemeNetworkClient,\n} from \"@x402/core/types\";\nimport { PaymentRequirementsV1 } from \"@x402/core/types/v1\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../../constants\";\nimport { ClientEvmSigner } from \"../../../signer\";\nimport { ExactEvmPayloadV1 } from \"../../../types\";\nimport { createNonce, getEvmChainId } from \"../../../utils\";\n\n/**\n * EVM client implementation for the Exact payment scheme (V1).\n */\nexport class ExactEvmSchemeV1 implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClientV1 instance.\n   *\n   * @param signer - The EVM signer for client operations\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme (V1).\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<\n    Pick<PaymentPayload, \"x402Version\" | \"payload\"> & { scheme: string; network: Network }\n  > {\n    const selectedV1 = paymentRequirements as unknown as PaymentRequirementsV1;\n    const nonce = createNonce();\n    const now = Math.floor(Date.now() / 1000);\n\n    const authorization: ExactEvmPayloadV1[\"authorization\"] = {\n      from: this.signer.address,\n      to: getAddress(selectedV1.payTo),\n      value: selectedV1.maxAmountRequired,\n      validAfter: (now - 600).toString(), // 10 minutes before\n      validBefore: (now + selectedV1.maxTimeoutSeconds).toString(),\n      nonce,\n    };\n\n    // Sign the authorization\n    const signature = await this.signAuthorization(authorization, selectedV1);\n\n    const payload: ExactEvmPayloadV1 = {\n      authorization,\n      signature,\n    };\n\n    return {\n      x402Version,\n      scheme: selectedV1.scheme,\n      network: selectedV1.network,\n      payload,\n    };\n  }\n\n  /**\n   * Sign the EIP-3009 authorization using EIP-712\n   *\n   * @param authorization - The authorization to sign\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to the signature\n   */\n  private async signAuthorization(\n    authorization: ExactEvmPayloadV1[\"authorization\"],\n    requirements: PaymentRequirementsV1,\n  ): Promise<`0x${string}`> {\n    const chainId = getEvmChainId(requirements.network);\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      throw new Error(\n        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n      );\n    }\n\n    const { name, version } = requirements.extra;\n\n    const domain = {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(requirements.asset),\n    };\n\n    const message = {\n      from: getAddress(authorization.from),\n      to: getAddress(authorization.to),\n      value: BigInt(authorization.value),\n      validAfter: BigInt(authorization.validAfter),\n      validBefore: BigInt(authorization.validBefore),\n      nonce: authorization.nonce,\n    };\n\n    return await this.signer.signTypedData({\n      domain,\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\",\n      message,\n    });\n  }\n}\n","export { ExactEvmSchemeV1 } from \"../exact/v1\";\n\nexport const NETWORKS: string[] = [\n  \"abstract\",\n  \"abstract-testnet\",\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n  \"polygon\",\n  \"polygon-amoy\",\n  \"peaq\",\n  \"story\",\n  \"educhain\",\n  \"skale-base-sepolia\",\n];\n","import { x402Facilitator } from \"@x402/core/facilitator\";\nimport { Network } from \"@x402/core/types\";\nimport { FacilitatorEvmSigner } from \"../../signer\";\nimport { ExactEvmScheme } from \"./scheme\";\nimport { ExactEvmSchemeV1 } from \"../v1/facilitator/scheme\";\nimport { NETWORKS } from \"../../v1\";\n\n/**\n * Configuration options for registering EVM schemes to an x402Facilitator\n */\nexport interface EvmFacilitatorConfig {\n  /**\n   * The EVM signer for facilitator operations (verify and settle)\n   */\n  signer: FacilitatorEvmSigner;\n\n  /**\n   * Networks to register (single network or array of networks)\n   * Examples: \"eip155:84532\", [\"eip155:84532\", \"eip155:1\"]\n   */\n  networks: Network | Network[];\n\n  /**\n   * If enabled, the facilitator will deploy ERC-4337 smart wallets\n   * via EIP-6492 when encountering undeployed contract signatures.\n   *\n   * @default false\n   */\n  deployERC4337WithEIP6492?: boolean;\n}\n\n/**\n * Registers EVM exact payment schemes to an x402Facilitator instance.\n *\n * This function registers:\n * - V2: Specified networks with ExactEvmScheme\n * - V1: All supported EVM networks with ExactEvmSchemeV1\n *\n * @param facilitator - The x402Facilitator instance to register schemes to\n * @param config - Configuration for EVM facilitator registration\n * @returns The facilitator instance for chaining\n *\n * @example\n * ```typescript\n * import { registerExactEvmScheme } from \"@x402/evm/exact/facilitator/register\";\n * import { x402Facilitator } from \"@x402/core/facilitator\";\n * import { createPublicClient, createWalletClient } from \"viem\";\n *\n * const facilitator = new x402Facilitator();\n *\n * // Single network\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: \"eip155:84532\"  // Base Sepolia\n * });\n *\n * // Multiple networks (will auto-derive eip155:* pattern)\n * registerExactEvmScheme(facilitator, {\n *   signer: combinedClient,\n *   networks: [\"eip155:84532\", \"eip155:1\"]  // Base Sepolia and Mainnet\n * });\n * ```\n */\nexport function registerExactEvmScheme(\n  facilitator: x402Facilitator,\n  config: EvmFacilitatorConfig,\n): x402Facilitator {\n  // Register V2 scheme with specified networks\n  facilitator.register(\n    config.networks,\n    new ExactEvmScheme(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  // Register all V1 networks\n  facilitator.registerV1(\n    NETWORKS as Network[],\n    new ExactEvmSchemeV1(config.signer, {\n      deployERC4337WithEIP6492: config.deployERC4337WithEIP6492,\n    }),\n  );\n\n  return facilitator;\n}\n"],"mappings":"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","names":["import_viem","import_viem","import_viem"]}