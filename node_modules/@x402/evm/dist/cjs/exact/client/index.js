"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/exact/client/index.ts
var client_exports = {};
__export(client_exports, {
  ExactEvmScheme: () => ExactEvmScheme,
  registerExactEvmScheme: () => registerExactEvmScheme
});
module.exports = __toCommonJS(client_exports);

// src/exact/client/scheme.ts
var import_viem2 = require("viem");

// src/constants.ts
var authorizationTypes = {
  TransferWithAuthorization: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "validAfter", type: "uint256" },
    { name: "validBefore", type: "uint256" },
    { name: "nonce", type: "bytes32" }
  ]
};

// src/utils.ts
var import_viem = require("viem");
function getEvmChainId(network) {
  const networkMap = {
    base: 8453,
    "base-sepolia": 84532,
    ethereum: 1,
    sepolia: 11155111,
    polygon: 137,
    "polygon-amoy": 80002
  };
  return networkMap[network] || 1;
}
function createNonce() {
  const cryptoObj = typeof globalThis.crypto !== "undefined" ? globalThis.crypto : globalThis.crypto;
  if (!cryptoObj) {
    throw new Error("Crypto API not available");
  }
  return (0, import_viem.toHex)(cryptoObj.getRandomValues(new Uint8Array(32)));
}

// src/exact/client/scheme.ts
var ExactEvmScheme = class {
  /**
   * Creates a new ExactEvmClient instance.
   *
   * @param signer - The EVM signer for client operations
   */
  constructor(signer) {
    this.signer = signer;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme.
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @returns Promise resolving to a payment payload
   */
  async createPaymentPayload(x402Version, paymentRequirements) {
    const nonce = createNonce();
    const now = Math.floor(Date.now() / 1e3);
    const authorization = {
      from: this.signer.address,
      to: (0, import_viem2.getAddress)(paymentRequirements.payTo),
      value: paymentRequirements.amount,
      validAfter: (now - 600).toString(),
      // 10 minutes before
      validBefore: (now + paymentRequirements.maxTimeoutSeconds).toString(),
      nonce
    };
    const signature = await this.signAuthorization(authorization, paymentRequirements);
    const payload = {
      authorization,
      signature
    };
    return {
      x402Version,
      payload
    };
  }
  /**
   * Sign the EIP-3009 authorization using EIP-712
   *
   * @param authorization - The authorization to sign
   * @param requirements - The payment requirements
   * @returns Promise resolving to the signature
   */
  async signAuthorization(authorization, requirements) {
    const chainId = parseInt(requirements.network.split(":")[1]);
    if (!requirements.extra?.name || !requirements.extra?.version) {
      throw new Error(
        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`
      );
    }
    const { name, version } = requirements.extra;
    const domain = {
      name,
      version,
      chainId,
      verifyingContract: (0, import_viem2.getAddress)(requirements.asset)
    };
    const message = {
      from: (0, import_viem2.getAddress)(authorization.from),
      to: (0, import_viem2.getAddress)(authorization.to),
      value: BigInt(authorization.value),
      validAfter: BigInt(authorization.validAfter),
      validBefore: BigInt(authorization.validBefore),
      nonce: authorization.nonce
    };
    return await this.signer.signTypedData({
      domain,
      types: authorizationTypes,
      primaryType: "TransferWithAuthorization",
      message
    });
  }
};

// src/exact/v1/client/scheme.ts
var import_viem3 = require("viem");
var ExactEvmSchemeV1 = class {
  /**
   * Creates a new ExactEvmClientV1 instance.
   *
   * @param signer - The EVM signer for client operations
   */
  constructor(signer) {
    this.signer = signer;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme (V1).
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @returns Promise resolving to a payment payload
   */
  async createPaymentPayload(x402Version, paymentRequirements) {
    const selectedV1 = paymentRequirements;
    const nonce = createNonce();
    const now = Math.floor(Date.now() / 1e3);
    const authorization = {
      from: this.signer.address,
      to: (0, import_viem3.getAddress)(selectedV1.payTo),
      value: selectedV1.maxAmountRequired,
      validAfter: (now - 600).toString(),
      // 10 minutes before
      validBefore: (now + selectedV1.maxTimeoutSeconds).toString(),
      nonce
    };
    const signature = await this.signAuthorization(authorization, selectedV1);
    const payload = {
      authorization,
      signature
    };
    return {
      x402Version,
      scheme: selectedV1.scheme,
      network: selectedV1.network,
      payload
    };
  }
  /**
   * Sign the EIP-3009 authorization using EIP-712
   *
   * @param authorization - The authorization to sign
   * @param requirements - The payment requirements
   * @returns Promise resolving to the signature
   */
  async signAuthorization(authorization, requirements) {
    const chainId = getEvmChainId(requirements.network);
    if (!requirements.extra?.name || !requirements.extra?.version) {
      throw new Error(
        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`
      );
    }
    const { name, version } = requirements.extra;
    const domain = {
      name,
      version,
      chainId,
      verifyingContract: (0, import_viem3.getAddress)(requirements.asset)
    };
    const message = {
      from: (0, import_viem3.getAddress)(authorization.from),
      to: (0, import_viem3.getAddress)(authorization.to),
      value: BigInt(authorization.value),
      validAfter: BigInt(authorization.validAfter),
      validBefore: BigInt(authorization.validBefore),
      nonce: authorization.nonce
    };
    return await this.signer.signTypedData({
      domain,
      types: authorizationTypes,
      primaryType: "TransferWithAuthorization",
      message
    });
  }
};

// src/exact/v1/facilitator/scheme.ts
var import_viem4 = require("viem");

// src/v1/index.ts
var NETWORKS = [
  "abstract",
  "abstract-testnet",
  "base-sepolia",
  "base",
  "avalanche-fuji",
  "avalanche",
  "iotex",
  "sei",
  "sei-testnet",
  "polygon",
  "polygon-amoy",
  "peaq",
  "story",
  "educhain",
  "skale-base-sepolia"
];

// src/exact/client/register.ts
function registerExactEvmScheme(client, config) {
  if (config.networks && config.networks.length > 0) {
    config.networks.forEach((network) => {
      client.register(network, new ExactEvmScheme(config.signer));
    });
  } else {
    client.register("eip155:*", new ExactEvmScheme(config.signer));
  }
  NETWORKS.forEach((network) => {
    client.registerV1(network, new ExactEvmSchemeV1(config.signer));
  });
  if (config.policies) {
    config.policies.forEach((policy) => {
      client.registerPolicy(policy);
    });
  }
  return client;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExactEvmScheme,
  registerExactEvmScheme
});
//# sourceMappingURL=index.js.map