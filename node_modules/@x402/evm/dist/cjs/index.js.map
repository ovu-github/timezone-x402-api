{"version":3,"sources":["../../src/index.ts","../../src/exact/client/scheme.ts","../../src/constants.ts","../../src/utils.ts","../../src/signer.ts"],"sourcesContent":["/**\n * @module @x402/evm - x402 Payment Protocol EVM Implementation\n *\n * This module provides the EVM-specific implementation of the x402 payment protocol.\n */\n\n// Export EVM implementation modules here\n// The actual implementation logic will be added by copying from the core/src/schemes/evm folder\n\nexport { ExactEvmScheme } from \"./exact\";\nexport { toClientEvmSigner, toFacilitatorEvmSigner } from \"./signer\";\nexport type { ClientEvmSigner, FacilitatorEvmSigner } from \"./signer\";\n","import { PaymentPayload, PaymentRequirements, SchemeNetworkClient } from \"@x402/core/types\";\nimport { getAddress } from \"viem\";\nimport { authorizationTypes } from \"../../constants\";\nimport { ClientEvmSigner } from \"../../signer\";\nimport { ExactEvmPayloadV2 } from \"../../types\";\nimport { createNonce } from \"../../utils\";\n\n/**\n * EVM client implementation for the Exact payment scheme.\n *\n */\nexport class ExactEvmScheme implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactEvmClient instance.\n   *\n   * @param signer - The EVM signer for client operations\n   */\n  constructor(private readonly signer: ClientEvmSigner) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<Pick<PaymentPayload, \"x402Version\" | \"payload\">> {\n    const nonce = createNonce();\n    const now = Math.floor(Date.now() / 1000);\n\n    const authorization: ExactEvmPayloadV2[\"authorization\"] = {\n      from: this.signer.address,\n      to: getAddress(paymentRequirements.payTo),\n      value: paymentRequirements.amount,\n      validAfter: (now - 600).toString(), // 10 minutes before\n      validBefore: (now + paymentRequirements.maxTimeoutSeconds).toString(),\n      nonce,\n    };\n\n    // Sign the authorization\n    const signature = await this.signAuthorization(authorization, paymentRequirements);\n\n    const payload: ExactEvmPayloadV2 = {\n      authorization,\n      signature,\n    };\n\n    return {\n      x402Version,\n      payload,\n    };\n  }\n\n  /**\n   * Sign the EIP-3009 authorization using EIP-712\n   *\n   * @param authorization - The authorization to sign\n   * @param requirements - The payment requirements\n   * @returns Promise resolving to the signature\n   */\n  private async signAuthorization(\n    authorization: ExactEvmPayloadV2[\"authorization\"],\n    requirements: PaymentRequirements,\n  ): Promise<`0x${string}`> {\n    const chainId = parseInt(requirements.network.split(\":\")[1]);\n\n    if (!requirements.extra?.name || !requirements.extra?.version) {\n      throw new Error(\n        `EIP-712 domain parameters (name, version) are required in payment requirements for asset ${requirements.asset}`,\n      );\n    }\n\n    const { name, version } = requirements.extra;\n\n    const domain = {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(requirements.asset),\n    };\n\n    const message = {\n      from: getAddress(authorization.from),\n      to: getAddress(authorization.to),\n      value: BigInt(authorization.value),\n      validAfter: BigInt(authorization.validAfter),\n      validBefore: BigInt(authorization.validBefore),\n      nonce: authorization.nonce,\n    };\n\n    return await this.signer.signTypedData({\n      domain,\n      types: authorizationTypes,\n      primaryType: \"TransferWithAuthorization\",\n      message,\n    });\n  }\n}\n","// EIP-3009 TransferWithAuthorization types for EIP-712 signing\nexport const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n} as const;\n\n// EIP3009 ABI for transferWithAuthorization function\nexport const eip3009ABI = [\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"v\", type: \"uint8\" },\n      { name: \"r\", type: \"bytes32\" },\n      { name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { name: \"from\", type: \"address\" },\n      { name: \"to\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"validAfter\", type: \"uint256\" },\n      { name: \"validBefore\", type: \"uint256\" },\n      { name: \"nonce\", type: \"bytes32\" },\n      { name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n] as const;\n","import { toHex } from \"viem\";\nimport { Network } from \"@x402/core/types\";\n\n/**\n * Extract chain ID from network string (e.g., \"base-sepolia\" -> 84532)\n * Used by v1 implementations\n *\n * @param network - The network identifier\n * @returns The numeric chain ID\n */\nexport function getEvmChainId(network: Network): number {\n  const networkMap: Record<string, number> = {\n    base: 8453,\n    \"base-sepolia\": 84532,\n    ethereum: 1,\n    sepolia: 11155111,\n    polygon: 137,\n    \"polygon-amoy\": 80002,\n  };\n  return networkMap[network] || 1;\n}\n\n/**\n * Create a random 32-byte nonce for authorization\n *\n * @returns A hex-encoded 32-byte nonce\n */\nexport function createNonce(): `0x${string}` {\n  // Use dynamic import to avoid require() in ESM context\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\"\n      ? globalThis.crypto\n      : (globalThis as { crypto?: Crypto }).crypto;\n\n  if (!cryptoObj) {\n    throw new Error(\"Crypto API not available\");\n  }\n\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","/**\n * ClientEvmSigner - Used by x402 clients to sign payment authorizations\n * This is typically a LocalAccount or wallet that holds private keys\n * and can sign EIP-712 typed data for payment authorizations\n */\nexport type ClientEvmSigner = {\n  readonly address: `0x${string}`;\n  signTypedData(message: {\n    domain: Record<string, unknown>;\n    types: Record<string, unknown>;\n    primaryType: string;\n    message: Record<string, unknown>;\n  }): Promise<`0x${string}`>;\n};\n\n/**\n * FacilitatorEvmSigner - Used by x402 facilitators to verify and settle payments\n * This is typically a viem PublicClient + WalletClient combination that can\n * read contract state, verify signatures, write transactions, and wait for receipts\n *\n * Supports multiple addresses for load balancing, key rotation, and high availability\n */\nexport type FacilitatorEvmSigner = {\n  /**\n   * Get all addresses this facilitator can use for signing\n   * Enables dynamic address selection for load balancing and key rotation\n   */\n  getAddresses(): readonly `0x${string}`[];\n\n  readContract(args: {\n    address: `0x${string}`;\n    abi: readonly unknown[];\n    functionName: string;\n    args?: readonly unknown[];\n  }): Promise<unknown>;\n  verifyTypedData(args: {\n    address: `0x${string}`;\n    domain: Record<string, unknown>;\n    types: Record<string, unknown>;\n    primaryType: string;\n    message: Record<string, unknown>;\n    signature: `0x${string}`;\n  }): Promise<boolean>;\n  writeContract(args: {\n    address: `0x${string}`;\n    abi: readonly unknown[];\n    functionName: string;\n    args: readonly unknown[];\n  }): Promise<`0x${string}`>;\n  sendTransaction(args: { to: `0x${string}`; data: `0x${string}` }): Promise<`0x${string}`>;\n  waitForTransactionReceipt(args: { hash: `0x${string}` }): Promise<{ status: string }>;\n  getCode(args: { address: `0x${string}` }): Promise<`0x${string}` | undefined>;\n};\n\n/**\n * Converts a signer to a ClientEvmSigner\n *\n * @param signer - The signer to convert to a ClientEvmSigner\n * @returns The converted signer\n */\nexport function toClientEvmSigner(signer: ClientEvmSigner): ClientEvmSigner {\n  return signer;\n}\n\n/**\n * Converts a viem client with single address to a FacilitatorEvmSigner\n * Wraps the single address in a getAddresses() function for compatibility\n *\n * @param client - The client to convert (must have 'address' property)\n * @returns FacilitatorEvmSigner with getAddresses() support\n */\nexport function toFacilitatorEvmSigner(\n  client: Omit<FacilitatorEvmSigner, \"getAddresses\"> & { address: `0x${string}` },\n): FacilitatorEvmSigner {\n  return {\n    ...client,\n    getAddresses: () => [client.address],\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,IAAAA,eAA2B;;;ACApB,IAAM,qBAAqB;AAAA,EAChC,2BAA2B;AAAA,IACzB,EAAE,MAAM,QAAQ,MAAM,UAAU;AAAA,IAChC,EAAE,MAAM,MAAM,MAAM,UAAU;AAAA,IAC9B,EAAE,MAAM,SAAS,MAAM,UAAU;AAAA,IACjC,EAAE,MAAM,cAAc,MAAM,UAAU;AAAA,IACtC,EAAE,MAAM,eAAe,MAAM,UAAU;AAAA,IACvC,EAAE,MAAM,SAAS,MAAM,UAAU;AAAA,EACnC;AACF;;;ACVA,kBAAsB;AA2Bf,SAAS,cAA6B;AAE3C,QAAM,YACJ,OAAO,WAAW,WAAW,cACzB,WAAW,SACV,WAAmC;AAE1C,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,0BAA0B;AAAA,EAC5C;AAEA,aAAO,mBAAM,UAAU,gBAAgB,IAAI,WAAW,EAAE,CAAC,CAAC;AAC5D;;;AF5BO,IAAM,iBAAN,MAAoD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQzD,YAA6B,QAAyB;AAAzB;AAP7B,SAAS,SAAS;AAAA,EAOqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASvD,MAAM,qBACJ,aACA,qBAC0D;AAC1D,UAAM,QAAQ,YAAY;AAC1B,UAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAExC,UAAM,gBAAoD;AAAA,MACxD,MAAM,KAAK,OAAO;AAAA,MAClB,QAAI,yBAAW,oBAAoB,KAAK;AAAA,MACxC,OAAO,oBAAoB;AAAA,MAC3B,aAAa,MAAM,KAAK,SAAS;AAAA;AAAA,MACjC,cAAc,MAAM,oBAAoB,mBAAmB,SAAS;AAAA,MACpE;AAAA,IACF;AAGA,UAAM,YAAY,MAAM,KAAK,kBAAkB,eAAe,mBAAmB;AAEjF,UAAM,UAA6B;AAAA,MACjC;AAAA,MACA;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,kBACZ,eACA,cACwB;AACxB,UAAM,UAAU,SAAS,aAAa,QAAQ,MAAM,GAAG,EAAE,CAAC,CAAC;AAE3D,QAAI,CAAC,aAAa,OAAO,QAAQ,CAAC,aAAa,OAAO,SAAS;AAC7D,YAAM,IAAI;AAAA,QACR,4FAA4F,aAAa,KAAK;AAAA,MAChH;AAAA,IACF;AAEA,UAAM,EAAE,MAAM,QAAQ,IAAI,aAAa;AAEvC,UAAM,SAAS;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA,uBAAmB,yBAAW,aAAa,KAAK;AAAA,IAClD;AAEA,UAAM,UAAU;AAAA,MACd,UAAM,yBAAW,cAAc,IAAI;AAAA,MACnC,QAAI,yBAAW,cAAc,EAAE;AAAA,MAC/B,OAAO,OAAO,cAAc,KAAK;AAAA,MACjC,YAAY,OAAO,cAAc,UAAU;AAAA,MAC3C,aAAa,OAAO,cAAc,WAAW;AAAA,MAC7C,OAAO,cAAc;AAAA,IACvB;AAEA,WAAO,MAAM,KAAK,OAAO,cAAc;AAAA,MACrC;AAAA,MACA,OAAO;AAAA,MACP,aAAa;AAAA,MACb;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AG1CO,SAAS,kBAAkB,QAA0C;AAC1E,SAAO;AACT;AASO,SAAS,uBACd,QACsB;AACtB,SAAO;AAAA,IACL,GAAG;AAAA,IACH,cAAc,MAAM,CAAC,OAAO,OAAO;AAAA,EACrC;AACF;","names":["import_viem"]}